# frozen_string_literal: true

# #TMDB API
#
# No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
#
# OpenAPI spec version: 3
#
# Generated by: https://github.com/swagger-api/swagger-codegen.git
# Swagger Codegen version: 3.0.54

require 'date'

module SwaggerClient
  class InlineResponse200121Results
    attr_accessor :ae, :ar, :at, :au, :ba, :bb, :be, :bg, :bo, :br, :bs, :ca, :ch, :ci, :cl, :co, :cr, :cz, :de, :dk,
                  :_do, :dz, :ec, :eg, :es, :fi, :fr, :gb, :gf, :gh, :gq, :gt, :hk, :hn, :hr, :hu, :id, :ie, :il, :iq, :it, :jm, :jp, :ke, :kr, :lb, :ly, :md, :mk, :mu, :mx, :my, :mz, :ne, :ng, :nl, :no, :nz, :pa, :pe, :ph, :pl, :ps, :pt, :py, :ro, :rs, :ru, :sa, :sc, :se, :sg, :si, :sk, :sn, :sv, :th, :tr, :tt, :tw, :tz, :ug, :us, :uy, :ve, :za, :zm

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        'ae': :AE,
        'ar': :AR,
        'at': :AT,
        'au': :AU,
        'ba': :BA,
        'bb': :BB,
        'be': :BE,
        'bg': :BG,
        'bo': :BO,
        'br': :BR,
        'bs': :BS,
        'ca': :CA,
        'ch': :CH,
        'ci': :CI,
        'cl': :CL,
        'co': :CO,
        'cr': :CR,
        'cz': :CZ,
        'de': :DE,
        'dk': :DK,
        '_do': :DO,
        'dz': :DZ,
        'ec': :EC,
        'eg': :EG,
        'es': :ES,
        'fi': :FI,
        'fr': :FR,
        'gb': :GB,
        'gf': :GF,
        'gh': :GH,
        'gq': :GQ,
        'gt': :GT,
        'hk': :HK,
        'hn': :HN,
        'hr': :HR,
        'hu': :HU,
        'id': :ID,
        'ie': :IE,
        'il': :IL,
        'iq': :IQ,
        'it': :IT,
        'jm': :JM,
        'jp': :JP,
        'ke': :KE,
        'kr': :KR,
        'lb': :LB,
        'ly': :LY,
        'md': :MD,
        'mk': :MK,
        'mu': :MU,
        'mx': :MX,
        'my': :MY,
        'mz': :MZ,
        'ne': :NE,
        'ng': :NG,
        'nl': :NL,
        'no': :NO,
        'nz': :NZ,
        'pa': :PA,
        'pe': :PE,
        'ph': :PH,
        'pl': :PL,
        'ps': :PS,
        'pt': :PT,
        'py': :PY,
        'ro': :RO,
        'rs': :RS,
        'ru': :RU,
        'sa': :SA,
        'sc': :SC,
        'se': :SE,
        'sg': :SG,
        'si': :SI,
        'sk': :SK,
        'sn': :SN,
        'sv': :SV,
        'th': :TH,
        'tr': :TR,
        'tt': :TT,
        'tw': :TW,
        'tz': :TZ,
        'ug': :UG,
        'us': :US,
        'uy': :UY,
        've': :VE,
        'za': :ZA,
        'zm': :ZM
      }
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        'ae': :Object,
        'ar': :Object,
        'at': :Object,
        'au': :Object,
        'ba': :Object,
        'bb': :Object,
        'be': :Object,
        'bg': :Object,
        'bo': :Object,
        'br': :Object,
        'bs': :Object,
        'ca': :Object,
        'ch': :Object,
        'ci': :Object,
        'cl': :Object,
        'co': :Object,
        'cr': :Object,
        'cz': :Object,
        'de': :Object,
        'dk': :Object,
        '_do': :Object,
        'dz': :Object,
        'ec': :Object,
        'eg': :Object,
        'es': :Object,
        'fi': :Object,
        'fr': :Object,
        'gb': :Object,
        'gf': :Object,
        'gh': :Object,
        'gq': :Object,
        'gt': :Object,
        'hk': :Object,
        'hn': :Object,
        'hr': :Object,
        'hu': :Object,
        'id': :Object,
        'ie': :Object,
        'il': :Object,
        'iq': :Object,
        'it': :Object,
        'jm': :Object,
        'jp': :Object,
        'ke': :Object,
        'kr': :Object,
        'lb': :Object,
        'ly': :Object,
        'md': :Object,
        'mk': :Object,
        'mu': :Object,
        'mx': :Object,
        'my': :Object,
        'mz': :Object,
        'ne': :Object,
        'ng': :Object,
        'nl': :Object,
        'no': :Object,
        'nz': :Object,
        'pa': :Object,
        'pe': :Object,
        'ph': :Object,
        'pl': :Object,
        'ps': :Object,
        'pt': :Object,
        'py': :Object,
        'ro': :Object,
        'rs': :Object,
        'ru': :Object,
        'sa': :Object,
        'sc': :Object,
        'se': :Object,
        'sg': :Object,
        'si': :Object,
        'sk': :Object,
        'sn': :Object,
        'sv': :Object,
        'th': :Object,
        'tr': :Object,
        'tt': :Object,
        'tw': :Object,
        'tz': :Object,
        'ug': :Object,
        'us': :Object,
        'uy': :Object,
        've': :Object,
        'za': :Object,
        'zm': :Object
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      unless attributes.is_a?(Hash)
        raise ArgumentError,
              'The input argument (attributes) must be a hash in `SwaggerClient::InlineResponse200121Results` initialize method'
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) do |(k, v), h|
        unless self.class.attribute_map.key?(k.to_sym)
          raise ArgumentError,
                "`#{k}` is not a valid attribute in `SwaggerClient::InlineResponse200121Results`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end

        h[k.to_sym] = v
      end

      self.ae = attributes[:ae] if attributes.key?(:ae)

      self.ar = attributes[:ar] if attributes.key?(:ar)

      self.at = attributes[:at] if attributes.key?(:at)

      self.au = attributes[:au] if attributes.key?(:au)

      self.ba = attributes[:ba] if attributes.key?(:ba)

      self.bb = attributes[:bb] if attributes.key?(:bb)

      self.be = attributes[:be] if attributes.key?(:be)

      self.bg = attributes[:bg] if attributes.key?(:bg)

      self.bo = attributes[:bo] if attributes.key?(:bo)

      self.br = attributes[:br] if attributes.key?(:br)

      self.bs = attributes[:bs] if attributes.key?(:bs)

      self.ca = attributes[:ca] if attributes.key?(:ca)

      self.ch = attributes[:ch] if attributes.key?(:ch)

      self.ci = attributes[:ci] if attributes.key?(:ci)

      self.cl = attributes[:cl] if attributes.key?(:cl)

      self.co = attributes[:co] if attributes.key?(:co)

      self.cr = attributes[:cr] if attributes.key?(:cr)

      self.cz = attributes[:cz] if attributes.key?(:cz)

      self.de = attributes[:de] if attributes.key?(:de)

      self.dk = attributes[:dk] if attributes.key?(:dk)

      self._do = attributes[:_do] if attributes.key?(:_do)

      self.dz = attributes[:dz] if attributes.key?(:dz)

      self.ec = attributes[:ec] if attributes.key?(:ec)

      self.eg = attributes[:eg] if attributes.key?(:eg)

      self.es = attributes[:es] if attributes.key?(:es)

      self.fi = attributes[:fi] if attributes.key?(:fi)

      self.fr = attributes[:fr] if attributes.key?(:fr)

      self.gb = attributes[:gb] if attributes.key?(:gb)

      self.gf = attributes[:gf] if attributes.key?(:gf)

      self.gh = attributes[:gh] if attributes.key?(:gh)

      self.gq = attributes[:gq] if attributes.key?(:gq)

      self.gt = attributes[:gt] if attributes.key?(:gt)

      self.hk = attributes[:hk] if attributes.key?(:hk)

      self.hn = attributes[:hn] if attributes.key?(:hn)

      self.hr = attributes[:hr] if attributes.key?(:hr)

      self.hu = attributes[:hu] if attributes.key?(:hu)

      self.id = attributes[:id] if attributes.key?(:id)

      self.ie = attributes[:ie] if attributes.key?(:ie)

      self.il = attributes[:il] if attributes.key?(:il)

      self.iq = attributes[:iq] if attributes.key?(:iq)

      self.it = attributes[:it] if attributes.key?(:it)

      self.jm = attributes[:jm] if attributes.key?(:jm)

      self.jp = attributes[:jp] if attributes.key?(:jp)

      self.ke = attributes[:ke] if attributes.key?(:ke)

      self.kr = attributes[:kr] if attributes.key?(:kr)

      self.lb = attributes[:lb] if attributes.key?(:lb)

      self.ly = attributes[:ly] if attributes.key?(:ly)

      self.md = attributes[:md] if attributes.key?(:md)

      self.mk = attributes[:mk] if attributes.key?(:mk)

      self.mu = attributes[:mu] if attributes.key?(:mu)

      self.mx = attributes[:mx] if attributes.key?(:mx)

      self.my = attributes[:my] if attributes.key?(:my)

      self.mz = attributes[:mz] if attributes.key?(:mz)

      self.ne = attributes[:ne] if attributes.key?(:ne)

      self.ng = attributes[:ng] if attributes.key?(:ng)

      self.nl = attributes[:nl] if attributes.key?(:nl)

      self.no = attributes[:no] if attributes.key?(:no)

      self.nz = attributes[:nz] if attributes.key?(:nz)

      self.pa = attributes[:pa] if attributes.key?(:pa)

      self.pe = attributes[:pe] if attributes.key?(:pe)

      self.ph = attributes[:ph] if attributes.key?(:ph)

      self.pl = attributes[:pl] if attributes.key?(:pl)

      self.ps = attributes[:ps] if attributes.key?(:ps)

      self.pt = attributes[:pt] if attributes.key?(:pt)

      self.py = attributes[:py] if attributes.key?(:py)

      self.ro = attributes[:ro] if attributes.key?(:ro)

      self.rs = attributes[:rs] if attributes.key?(:rs)

      self.ru = attributes[:ru] if attributes.key?(:ru)

      self.sa = attributes[:sa] if attributes.key?(:sa)

      self.sc = attributes[:sc] if attributes.key?(:sc)

      self.se = attributes[:se] if attributes.key?(:se)

      self.sg = attributes[:sg] if attributes.key?(:sg)

      self.si = attributes[:si] if attributes.key?(:si)

      self.sk = attributes[:sk] if attributes.key?(:sk)

      self.sn = attributes[:sn] if attributes.key?(:sn)

      self.sv = attributes[:sv] if attributes.key?(:sv)

      self.th = attributes[:th] if attributes.key?(:th)

      self.tr = attributes[:tr] if attributes.key?(:tr)

      self.tt = attributes[:tt] if attributes.key?(:tt)

      self.tw = attributes[:tw] if attributes.key?(:tw)

      self.tz = attributes[:tz] if attributes.key?(:tz)

      self.ug = attributes[:ug] if attributes.key?(:ug)

      self.us = attributes[:us] if attributes.key?(:us)

      self.uy = attributes[:uy] if attributes.key?(:uy)

      self.ve = attributes[:ve] if attributes.key?(:ve)

      self.za = attributes[:za] if attributes.key?(:za)

      return unless attributes.key?(:zm)

      self.zm = attributes[:zm]
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      []
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        ae == other.ae &&
        ar == other.ar &&
        at == other.at &&
        au == other.au &&
        ba == other.ba &&
        bb == other.bb &&
        be == other.be &&
        bg == other.bg &&
        bo == other.bo &&
        br == other.br &&
        bs == other.bs &&
        ca == other.ca &&
        ch == other.ch &&
        ci == other.ci &&
        cl == other.cl &&
        co == other.co &&
        cr == other.cr &&
        cz == other.cz &&
        de == other.de &&
        dk == other.dk &&
        _do == other._do &&
        dz == other.dz &&
        ec == other.ec &&
        eg == other.eg &&
        es == other.es &&
        fi == other.fi &&
        fr == other.fr &&
        gb == other.gb &&
        gf == other.gf &&
        gh == other.gh &&
        gq == other.gq &&
        gt == other.gt &&
        hk == other.hk &&
        hn == other.hn &&
        hr == other.hr &&
        hu == other.hu &&
        id == other.id &&
        ie == other.ie &&
        il == other.il &&
        iq == other.iq &&
        it == other.it &&
        jm == other.jm &&
        jp == other.jp &&
        ke == other.ke &&
        kr == other.kr &&
        lb == other.lb &&
        ly == other.ly &&
        md == other.md &&
        mk == other.mk &&
        mu == other.mu &&
        mx == other.mx &&
        my == other.my &&
        mz == other.mz &&
        ne == other.ne &&
        ng == other.ng &&
        nl == other.nl &&
        no == other.no &&
        nz == other.nz &&
        pa == other.pa &&
        pe == other.pe &&
        ph == other.ph &&
        pl == other.pl &&
        ps == other.ps &&
        pt == other.pt &&
        py == other.py &&
        ro == other.ro &&
        rs == other.rs &&
        ru == other.ru &&
        sa == other.sa &&
        sc == other.sc &&
        se == other.se &&
        sg == other.sg &&
        si == other.si &&
        sk == other.sk &&
        sn == other.sn &&
        sv == other.sv &&
        th == other.th &&
        tr == other.tr &&
        tt == other.tt &&
        tw == other.tw &&
        tz == other.tz &&
        ug == other.ug &&
        us == other.us &&
        uy == other.uy &&
        ve == other.ve &&
        za == other.za &&
        zm == other.zm
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [ae, ar, at, au, ba, bb, be, bg, bo, br, bs, ca, ch, ci, cl, co, cr, cz, de, dk, _do, dz, ec, eg, es, fi, fr, gb,
       gf, gh, gq, gt, hk, hn, hr, hu, id, ie, il, iq, it, jm, jp, ke, kr, lb, ly, md, mk, mu, mx, my, mz, ne, ng, nl, no, nz, pa, pe, ph, pl, ps, pt, py, ro, rs, ru, sa, sc, se, sg, si, sk, sn, sv, th, tr, tt, tw, tz, ug, us, uy, ve, za, zm].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.openapi_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            send("#{key}=", attributes[self.class.attribute_map[key]].map do |v|
                              _deserialize(::Regexp.last_match(1), v)
                            end)
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        elsif attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)
          send("#{key}=", nil)
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        SwaggerClient.const_get(type).build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end end
end
